#临毕业摸底测验（第一部分）
@(北京珠峰培训)
### JavaScript （前端玩家必备技能）
####1、 ele.getAttribute('propName') 和 ele.propName区别
> e.getAttribute('propName')：是标准DOM操作文档元素属性的方法，具有通用性可在任意文档上使用，返回元素在源文件中设置的属性"proName"
> ele.propName：e.propName是在HTML文档中访问propName的特性，对于没有对应特性的属性，只能使用getAttribute进行访问.返回值可能是字符串、布尔值、对象、undefined

####2、mouseover和mouseenter的区别
> 1、over属于滑过(覆盖)事件，从父元素进入到子元素，属于离开了父元素，会触发父元素的out，触发子元素的overenter属于进入，从父元素进入到子元素，并不算离开父元素，不会触发父元素的leave，触发子元素的enter
>2、enter和leave阻止了事件的冒泡传播，而over和out还存在冒泡传播的所以对于父元素嵌套子元素这种情况，使用over会发生很多不愿意操作的事情，此时我们使用enter会更加简单，操作方便，所以真实项目中enter的使用会比over多。

####3、什么是事件代理
> 一件容器中，很多后代元素的点击行为都要处理一些事情，只给容器绑定方法，这样不管点击的是哪个元素，都会基于事件的冒泡传播机制传递给这个容器，这就是事件代理。

####4、localStorage和cookie的区别，cookie和session的关系！
> Cookie：指某些网站为了辨别用户身份而存储在用户本地终端上的数据。
 内存 Cookie 由浏览器维护，保存在内存中，浏览器关闭就小时，存在时间短暂。
硬盘 Cookie 保存在硬盘中，除非用户手工清理或到了过期时间，一般不会删除。
用途：因为 HTTP 协议是无状态的，就是说服务器不知道用户上一次做了什么，为实现交互，就用 Cookie 来记录。
缺点：
1、Cookie 会被附加到每个 HTTP 请求中，无形增加了流量
2、HTTP请求中的 Cookie 是明文传递，安全性成问题。（HTTPS 不会）
3、Cookie 大小限制在 4KB，对于复杂的存储需求是不够用的
LocalStorage：本地存储，为每一个给定的源维持一个独立的存储区域，浏览器关闭之后，重新打开数据还是存在。存放数据大小一般为5MB
Cookie的数据声明周期一般由服务器生成，可设置失效时间。如果在浏览器生成，默认是关闭浏览器之后失效，local Storage除非被清除，否则永久保存
cookie和session区别：
cookie数据保存在客户端，session数据保存在服务器端。
Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。

####5、什么是闭包，你在项目中哪一块用到了闭包！
>闭包：函数形成一个私有的作用域，保护里面的变量不受外界干扰，这种保护机制叫做闭包(形成一个不销毁的栈内存，有保护和保存两个作用)
在真实项目中，尤其是团队协作开发的时候，应当尽可能的减少全局变量的使用，以防止相互之间的冲突("全局变量污染")，那么此时我们完全可以把自己这一部分内容封装到一个闭包中，让全局变量转换为私有变量。
我们封装类库、插件的时候，也会把自己的程序都存放到闭包中保护起来，防止和用户的程序冲突，我们需要暴露一些方法给客户使用：
1、JQ这种方式，把需要暴露的方法抛到全局
window.jQuery=window.$=jQuery; =>把需要供外面使用的方法，通过给WIN设置属性的方式暴露出去。
2、zepto这种方式:基于RETURN把需要供外面使用的方法暴露出去

####6、js中定义函数的方式有哪些，区别是什么！
>1、函数语句：使用 function 关键字显式定义函数。如：function f(x){return x+1;}
2、函数定义表达式：也称为“函数直接量”： var f = function(x){return x+1;};
3、使用 Function() 构造函数定义：Var f = new Function(“x”,”return x+1;”);
区别：
使用Function构造函数定义函数的方式是一个函数表达式，但是不推荐使用这种方式定义函数，原因在于这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串。
对于函数声明和函数表达式两种定义函数的方式而言，解析器并不是一视同仁的。解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；对于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

####7、说出你掌握的继承方式及优缺点，并加以改进！
>原型继承：
1、方式：子类的原型指向父类的实例  父类的实例本身就具备私有的属性和方法，子类的原型指向它，那么子类的实例就可以找到这些属性方法了
2、和传统后台语言的继承不一样，子类继承父类并不是把父类的属性方法克隆一份副本给子类，这样处理子类和父类就没有这些关系了，JS中的原型继承是让子类和父类建立原型连接的机制，子类的实例调取父类原型上的方法都是基于原型链机制完成的。
存在的问题：子类可以重写父类原型上的方法，子类和父类还有关系的。
原型继承存在的问题：
1、父类实例私有的属性以及公有的属性都变为子类实例的公有的属性
2、如果子类的原型上之前有属性方法，重新指向父类的子类后，之前的方法都没有了。
call继承：
原理：在子类型构造函数中调用超类型构造函数，由于函数本身就是可执行的代码块，因此这就和在子类型构造函数中直接设置属性和方法差不多。
优点：简单，可以在子类型中向父类型的构造函数传递参数
缺点：相同方法在不同对象的构造函数中都要定义一遍，无法实现函数复用。在超类型原型中定义的方法，对子类型是不可见的，因此所有的超类型的原型属性都不能被继承。
组合继承
原理：将原型链和借用构造函数的技术组合到一块，发挥二者之长的一种继承模式。
优点：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用,既是子类的实例也是父类的实例
缺点：调用两次父类型构造函数，生成两份实例（覆盖了父类型原型上的属性），消耗内存
寄生组合式继承
原理：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点
ES6中的类和继承Class
1、ES6中创建类是有自己标准语法的(这种语法创建的类只能new执行，不能当普通函数执行)
FN是类名，没有小括号
static AA(){} //把FN当做一个普通对象设置的私有方法(和实例没有关系)，但是也只能写方法不能写属性。
extends类似于实现了原型继承
class B extends A {  constructor{
super();//类似于call继承：在这里super相当于把A的constructor给执行了，并且让方法中的this是B的实例，super里面传的参都是给A的constructor传递}}

####8、说出ES6和ES5的区别！
>1）let 不存在变量提升机制，(变量不允许在声明之前使用)
2）let不允许重复声明
3)在全局作用域中基于let声明的变量不是window的一个属性，和他没关系
4）typeof 未被声明的变量 不是undefined而会报错(暂时性死区)
5）let 会形成块级作用域(类似于私有作用域 大部分大括号都会形成块级作用域)
ES6的解构赋值"..." 拓展、剩余、展开运算符
ES6的箭头函数和普通函数的区别
1）没有arguments 但是可以基于...arg获取实参集合(结果是一个数组)
2）没有自己的this，箭头函数中的this是上下文中的this
ES6模板字符串、promise(async/await)、class(ES6创建类的)、Map /Set

####9、阐述JS中的同步编程和异步编程，以及你在项目中是如何来使用异步操作的！
>同步编程：在一个线程上(主栈/主任务队列)同一个时间只能做一件事情，当前事情完成才能进行下一个事情
异步编程：在主栈中执行一个任务，但是发现这个任务是一个异步的操作，我们会把它移除主栈，放到等待任务队列当中(此时浏览器会分配其他线程监听异步任务是否到达指定的执行时间)，如果主栈执行完，监听者会把到达时间的异步任务重新放到主栈中执行
我们可以使用Promise来管理我们的异步操作，把所有有序的异步都放在Promise里，通过then链进行代码的规划。


####10、实现一个Promise
```
class Promise {
    constructor(excutor) {
        this.status = 'pending';
        this.value = undefined;
        this.fulfilledAry = [];
        this.rejectedAry = [];
        let resolve = result => {
            let timer = setTimeout(() => {
                clearTimeout(timer);
                if (this.status !== 'pending') return;
                this.status = 'fulfilled';
                this.value = result;
                this.fulfilledAry.forEach(item => item(result));
            }, 0);
        };

        let reject = reason => {
            let timer = setTimeout(() => {
                clearTimeout(timer);
                if (this.status !== 'pending') return;
                this.status = 'rejected';
                this.value = reason;
                this.rejectedAry.forEach(item => item(reason));
            }, 0);
        };
        try {
            excutor(resolve, reject);
        } catch (e) {
            reject(e);
        }
    }
    then(fulfilledCallBack, rejectedCallBack) {
        typeof fulfilledCallBack !== 'function' ? fulfilledCallBack = () => {
            return this.value;
        } : null;
        typeof rejectedCallBack !== 'function' ? rejectedCallBack = () => {
            throw new Error(this.value);
        } : null;

        return new Promise((resolve, reject) => {
            this.fulfilledAry.push(() => {
                try {
                    let x = fulfilledCallBack(this.value);
                    x instanceof Promise ? x.then(resolve, reject) : resolve(x);
                } catch (e) {
                    reject(e);
                }
            });
            this.rejectedAry.push(() => {
                try {
                    let x = rejectedCallBack(this.value);
                    x instanceof Promise ? x.then(resolve, reject) : resolve(x);
                } catch (e) {
                    reject(e);
                }
            });
        });
    }
    catch(rejectedCallBack) {
        return this.then(null, rejectedCallBack);
    }
    static all(promiseAry) {
        return new Promise((resolve, reject) => {
            let resultAry = [],
                index = 0;
            for (let i = 0; i < promiseAry.length; i++) {
                promiseAry[i].then(result => {
                    index++;
                    resultAry[i] = result;
                    if (index === promiseAry.length) {
                        resolve(resultAry);
                    }
                }).catch(reason => {
                    reject(reason);
                });
            }
        });
    }
}
module.exports = Promise;
```

###HTTP && AJAX && 跨域
####1、 写出项目中经常用到的性能优化方案
>1、在JS中尽量减少闭包的使用(原因：闭包会产生不释放的栈内存)
2、尽量合并CSS和JS文件(把需要引入的CSS合并为一个，JS也是合并为一个)，原理是在减少HTTP请求次数，尽可能的把合并后的代码进行压缩，减少HTTP请求大小
3、尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片(因为字体图标等是矢量图)基于代码编写出来的，放大不会变形，而且渲染速度快，相比位图要小一些
4、减少对DOM的操作(主要减少DOM的重绘和回流(重排))
5、做CDN加速 地域式服务器发布，在热门地域附近设置服务器机组，附近的用户方向都是离其最近的机组(提供访问速度)
以上都是为了减少HTTP请求次数和请求大小

####2、从浏览器地址栏输入URL到显示页面，中间都经历了什么（尽可能写详细，最好回答出TCP的三次握手和四次挥手，以及浏览器加载页面的细节）
>中间经历了：
[HTTP请求阶段：向服务器发送请求]
1、浏览器首先向DNS域名解析服务器发送请求
2、DNS反解析:根据浏览器请求地址中的域名，到DNS服务器中找到对应的服务器外网IP地址
3、通过找到外网IP地址向对应的服务器发送请求(首先访问的是服务器的WEB站点管理工具:准确来说是我们先基于工具创建很多服务，当客户端访问的时候，服务器会匹配出具体是请求哪个服务)
4、通过URL地址中携带的端口号找到服务器上对应的服务，以及服务器上所管理的项目资源文件
[HTTP响应阶段：服务器吧客户端需要的内容准备好，并且返回给客户端]
5、服务器端根据请求地址中的路径名称、问号传参或者哈希值，把客户端需要的内容进行准备和处理
6、把准备的内容响应给客户端(如果请求的是HTML或者CSS等这样的资源文件，服务器返回的是资源文件中的源代码(不是文件本身))
[浏览器渲染阶段]
7、客户端浏览器接收到服务器返回的源代码，基于自己内部的渲染引擎(内核)开始进行页面的绘制和渲染
三次握手和四次挥手：
TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；
TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。
TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。
当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。

####3、说出你所熟知的HTTP状态码！GET和POST有啥区别！
>200 OK 成功 (只能证明服务器成功返回信息了，不能信息不一定是你业务需要的)
301 Moved Permanently 永久转移(永久重定向)
=>域名更改，访问原始域名重定向到新的域名
302 Move temporarily临时转移(临时重定向 =>307)
 =>网站现在是基于HTTPS协议运作的，如果访问的是HTTP协议，会基于307重定向到HTTPS协议上
 => 302一般用作服务器负载均衡:当一台服务器达到最大并发数的时候，会把后续访问的用户临时转移到其他的服务器机组上的处理
  =>偶尔真实项目中会把真实的图片放到单独的服务器上"图片处理服务器"，这样减少主服务器的压力，当用户向主服务器访问图片的时候，主服务器都把它转移到图片服务器上处理
304 Not Modified 设置缓存
=>对于不经常更新的资源文件，例如：CSS、JS、HTML、IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取，如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取，基于CTRL+F5强制刷新页面，304做的缓存就没有用了
400 Bad Request 请求参数错误
401 Unauthorizen 无权限
404 Not Found 找不到资源（地址不存在）
407 需要代理授权
413 Request Entity Too Large 和服务器交互的内容资源超过服务器最大限制
500 Internal Server Error 未知的服务器错误
503 Service Unavailable 服务器超负荷

`GET VS POST`
>【传递给服务器信息的方式不一行】
GET是基于URL地址问号传参的方式把信息传递给服务器，POST是基于请求主体把信息传递给服务器
xhr.send()//请求主体中传递给服务器的是JSON格式的字符串，但是真实项目中常用的是URL-ENCONDE格式的字符串"id=1000&lx=2000"
GET一般应用于拿(给服务器的少一些)，而post给服务器的多，如果POST是基于问号传参方式来搞会出现一些问题:URL会拼接很长，浏览器对于URL的长度都有最大限度(谷歌8KB 火狐 7KB IE 2KB。。。)超过的部分浏览器就把它截掉了 =>所以get请求可以基于URL传参，POST都是使用请求主体传递(请求主体理论上是没有限制的，真实项目中我们会自己做大小限制，防止上传过大信息导致请求迟迟完不成)
[get不安全，POST相对安全]
因为GET是基于"问号传参"把信息传递给服务器的，容器被骇客进行URL劫持，POST是基于请求主体传递的，相对来说不好劫持:所以登录、注册等涉及安全性的交互操作，我们都应该用POST请求
[GET会产生不可控制的缓存，POST不会]
不可控：不是想要就要，想不要就不要，这是浏览器自主记忆的缓存，我们无法基于JS控制，真实项目中我们都会把这个缓存干掉。
GET请求产生缓存是因为:连续多次向相同的地址，并且传递的参数信息也是相同的，发送请求，浏览器会把之前获取的数据从缓存中拿到返回，导致无法获取服务器最新的数据(POST不会)


####4、什么是HTTP报文，你熟知的报文都有哪些！
>在客户端向服务器发送请求，以及服务器把内容响应给客户端的时候，中间相互传递了很多内容(客户端把很多内容传递给服务器，服务器把一些内容响应给客户端)，我们把传递的内容统称为"HTTP报文";
起始行：请求起始行、响应起始行
首部(头)：请求头、响应头、通用头
主体：请求主体、响应主体
General 通用头
通用头：
Request URL:请求地址
Request Method 请求方式 get/post/delete/put/head/option
Status Code 响应的HTTP状态码
Remote Address 主机地址(服务器外网IP地址)
Request Headers 请求头[客户端设置 ，服务器接收]：
GET / HTTP/1.1 起始行
Response Headers 响应头[服务器端设置，客户端获取]
HTTP/1.1 304 Not Modified =>响应起始行(HTTP状态码)
Response 响应主体(服务器返回的是啥就是啥)
Request Payload/Form Data [请求主体]

####5、 能说下304具体怎样实现吗？
>304 Not Modified 设置缓存
=>对于不经常更新的资源文件，例如：CSS、JS、HTML、IMG等，服务器会结合客户端设置304缓存，第一次加载过这些资源就缓存到客户端了，下次再获取的时候，是从缓存中获取，如果资源更新了，服务器端会通过最后修改时间来强制让客户端从服务器重新拉取，基于CTRL+F5强制刷新页面，304做的缓存就没有用了


####6、跨域是什么？http协议中如何判断跨域？如何解决跨域问题？
>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。
1、JSONP原理
ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。
2、代理：例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。


####7、HTTP2具体内容？SDPY了解么？
>1.新的二进制格式（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。基于这种考虑HTTP2.0的协议解析决定在 应用层(HTTP/2)和传输层(TCP or UDP)之间采用二进制格式，实现方便且健壮。在 应用层(HTTP/2)和传输层(TCP or UDP)之间。
2.多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。单链接是的内存更少，吞吐量变大。
3.header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。SPDY/2使用的是gzip压缩算法，但后来出现的两种攻击方式BREACH和CRIME使得即使走ssl的SPDY也可以被破解内容，最后综合考虑采用的是一种叫HPACK的压缩算法。这两个漏洞和相关算法可以点击链接查看更多的细节，不过这种漏洞主要存在于浏览器端，因为需要通过javascript来注入内容并观察payload的变化。
4.服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0，例如YouTuBe，淘宝网等网站，利用chrome控制台可以查看是否启用H2：
SDPY：
spdy被当作 HTTP/2 的基础，有不少改进
1：降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了线头阻塞的问题，降低了延迟同时提高了带宽的利用率。
2.请求优先级（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
3.header压缩。使用了Hpack压缩算法可以减小http的大小和数量。
4.基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。
5.服务端推送（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。


####8、HTTPS如何实现？tsl/ssl是什么？对称加密、非对称加密在什么时候、对什么数据加密？
>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输。
SSL（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。
TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，1999年从 3.1 开始被 IETF 标准化并改名，发展至今已经有 TLS 1.0、TLS 1.1、TLS 1.2 三个版本。SSL3.0和TLS1.0由于存在安全漏洞，已经很少被使用到。TLS 1.3 改动会比较大，目前还在草案阶段，目前使用最广泛的是TLS 1.1、TLS 1.2。
1、对称加密
有流式、分组两种，加密和解密都是使用的同一个密钥。
例如：DES、AES-GCM、ChaCha20-Poly1305等
2、非对称加密
加密使用的密钥和解密使用的密钥是不相同的，分别称为：公钥、私钥，公钥和算法都是公开的，私钥是保密的。非对称加密算法性能较低，但是安全性超强，由于其加密特性，非对称加密算法能加密的数据长度也是有限的。


####9、DNS劫持是什么？
>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。
原理：
DNS（域名系统）的作用是把网络地址（域名，以一个字符串的形式）对应到真实的计算机能够识别的网络地址（IP地址），以便计算机能够进一步通信，传递网址和内容等。由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器(DNS)能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施――封锁正常DNS的IP。
应对方案：
1、互联网公司准备两个以上的域名，一旦黑客进行DNS攻击，用户还可以访问另一个域名。
2、互联网应该对应急预案进行进一步修正，强化对域名服务商的协调流程。
3、域名注册商和代理机构特定时期可能成为集中攻击目标，需要加以防范。
4、国内有关机构之间应该快速建立与境外有关机构的协调和沟通，协助国内企业实现对此事件的快速及时的处理。

####10、封装一个AJAX库！
```
(function (window) {
    function AJAX(options) {
        return new Init(options);
    }
    let Init =function (options={}) {
        let {
            url,
            method='GET',
            data=null,
            dataType='json',
            async=true,
            cache=true,
            success,
            error
        } =options;
        //MOUNT: 把配置项挂载到实例上
        ['url','method','data','async','dataType','cache','success','error'].forEach(item=>{
            this[item]=eval(item);
        });
        //SEND
        this.sendAjax();
    };
    AJAX.prototype={
        constructor:AJAX,
        Init,
        //发送AJAX请求
        sendAjax(){
            //SEND
            this.handleData();
            this.handleCache();
            let {method,url,async,error,success,data}=this;
            let xhr =new XMLHttpRequest();
            xhr.open(method,url,async);
            xhr.onreadystatechange=()=>{

                //->SUCCESS
                if(xhr.readyState===4){
                    //ERROR
                    if(!/^(2|3)\d{2}$/.test(xhr.status)){
                        error && error(xhr.statusText,xhr);
                        return;
                    }
                    //处理dataType
                    let result =this.handleDataType(xhr);
                    success && success(result,xhr);
                }
            };
            xhr.send(data)
        },
        handleDataType(xhr){
            let {dataType}=this;
            dataType=dataType.toUpperCase();
            let result =xhr.responseText;
            switch (dataType){
                case 'TEXT':
                    break;
                case 'JSON':
                    result =JSON.parse(result);
                    break;
                case 'XML':
                    result=xhr.responseText;
                    break;
            }
            return result ;
        },
        //处理cache
        handleCache(){
            let {url,method,cache}=this;
            if(/^GET$/i.test(method)&& cache===false){
                url+=`${this.check()}_=${+(new Date())}`;//URL末尾追加时间戳
                this.url=url;

            }
        },
        //检测URL中是否存在问号

        //处理DATA
        handleData(){
            let {data,method}=this;
            if(!data) return ;
            if(typeof data ==='object'){
             //如果是个object 我们把它转化为x-www-form-urlencoded这种模式，方便后期传递给服务器
                let str =``;
                for (let key in data) {
                    if (data.hasOwnProperty(key)) {
                        str+=`${key}=${data[key]}&`;
                    }
                }
                str.length>0?data=str.substring(0,str.length-1):null;

            }
            //根据请求方式不一样，传递给服务器的方式也不同
            if(/^(GET|HEAD|DELETE|TRACT|OPTIONS)$/i.test(method)){
                this.url+=`${this.check()}${data}`;
                this.data =null;
                return ;
            }
            this.data=data; //POST系列
        },
        check(){
            return this.url.indexOf('?')>-1?'&':'?';
        }

    };
    Init.prototype=AJAX.prototype;
    window.ajax=AJAX;
})(window);
```
